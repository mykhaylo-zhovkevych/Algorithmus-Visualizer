<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Archive</title>
    <style>

    @import 'normalize.css' layer(normalize);

    @layer normalize, base, demo;

    @layer demo {
    
    :root {
        --ease: linear(
        0 0%, 0.0039 6.25%, 0.0156 12.5%,
        0.0352 18.75%, 0.0625 25%,
        0.0977 31.25%, 0.1407 37.5%,
        0.1914 43.74%, 0.2499 49.99%,
        0.3164 56.25%, 0.3906 62.5%, 0.5625 75%,
        0.7656 87.5%, 1 100%
    );
    }
    

    summary {
        width: 100%;
        padding-block: 1rem;
        border-bottom: 1px solid canvasText;
    }

    summary:focus-visible {
        outline-offset: 4px;
        outline-color: red;
    }

    details span {
        display: inline-block;
        width: 100%;
        overflow: hidden;
        font-weight: 300;
        transition-duration: 1s;
        padding-block: 1rem;
    }

    details {
        width: 70ch;
    }
    
    details {
        interpolate-size: allow-keywords;
    }

    details::details-content {
        overflow: hidden;
        opacity: 0;
        height: 0;
        filter: blur(4px);
        translate: 0 1lh;
        transition: content-visibility, opacity, height, background, filter, translate;
        transition-behavior: allow-discrete;
        transition-duration: calc(var(--duration, 0.5) * 1s);
        transition-timing-function: var(--ease);
        mask: linear-gradient(#000 calc(100% - 1rem), #0000);
    }

    [open]::details-content {
      height: fit-content;
      filter: blur(0px);
      opacity: 1;
      translate: 0 0;
  }

    summary {
        display: flex;
        font-weight: 600;
        cursor: pointer;
        position: relative;
        padding-block: 1rem;

    }

    summary::after {
        content: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke-width='1.5' stroke='currentColor' %3E%3Cpath stroke-linecap='round' stroke-linejoin='round' d='M19.5 8.25l-7.5 7.5-7.5-7.5' /%3E%3C/svg%3E%0A");
        position: absolute;
        top: 50%;
        right: 0;
        width: 20px;
        translate: 0 -35%;
        transition: scale calc(var(--duration, 0.5) * 1s) var(--ease);
        transform-origin: 50% 40%;
    }

    [data-theme='dark'] summary::after {
        filter: invert(-1);
    }

  
    @media (prefers-color-scheme: dark) {
        summary::after {
        filter: invert(1);
        }
    }

    details[open] summary::after {
        scale: -1;
    }
    }

    @layer base {
    *,
    *:after,
    *:before {
        box-sizing: border-box;
    }

    body {
        display: flex;
        justify-content: center; 
        align-items: center;   
        min-height: 100vh;      
        margin: 0;
    }

  
    ::view-transition-new(root) {
      animation: fadeInScale calc(var(--duration) * 5s);
      z-index: 2;
      opacity: 0;
      transform: scale(0.8);
    }
  
    @keyframes fadeInScale {
      0% {
        opacity: 0;
        transform: scale(0.8);
      }
      100% {
        opacity: 1;
        transform: scale(1);
      }
  }
}
</style>
</head>
<body>
  <div class="list">
    <details name="accordion">
      <summary>Sortieralgorithmus Übersicht</summary>
      
      <span>Lorem ipsum, dolor sit amet consectetur adipisicing elit. Amet, corrupti?</span>
      <div>
        Die Daten werden analysiert und in bestimmter Reihenfolge dargestellt. Für eine anschauliche Visualisierung verwenden Sie ein Array mit 15 unterschiedlichen Zahlen.
      </div>
      <span>Lorem ipsum, dolor sit amet consectetur adipisicing elit. Amet, corrupti?</span>

    </details>

    <details name="accordion">
      <summary>Bubble Sort</summary>
      <div>
        Ein einfacher Vergleichsalgorithmus, bei dem benachbarte Elemente im Array wiederholt vertauscht werden, wenn sie in der falschen Reihenfolge sind. Dies wird so lange wiederholt, bis das gesamte Array sortiert ist.
      </div>
    </details>

    <details name="accordion">
      <summary>Insertion Sort</summary>
      <div>
        Ein Algorithmus, bei dem Elemente eines Arrays einzeln betrachtet und in die richtige Position in einem bereits sortierten Teil des Arrays eingefügt werden.
      </div>
    </details>

    <details name="accordion">
      <summary>Merge Sort</summary>
      <div>
        Ein effizienter, rekursiver Algorithmus, der das Array in kleinere Teile aufteilt, diese sortiert und anschliessend die sortierten Teile zu einem vollständigen Array zusammenführt.
      </div>
    </details>

    <details name="accordion">
      <summary>Quick Sort</summary>
      <div>
        Ein schneller, teilungsbasierter Algorithmus, der ein sogenanntes Pivot-Element wählt und das Array so aufteilt, dass kleinere Werte links und grössere Werte rechts vom Pivot stehen. Anschliessend wird der Prozess rekursiv wiederholt.
      </div>
    </details>

    <details name="accordion">
      <summary>Stalin Sort</summary>
      <div>
        Ein humoristischer Algorithmus, der Elemente entfernt, die nicht in aufsteigender Reihenfolge sind. Am Ende bleibt nur ein "sortiertes" Array, da unpassende Werte einfach eliminiert werden.
      </div>
    </details>

    <details name="accordion">
      <summary>Lineare Suche</summary>
      <div>
        Ein einfacher Suchalgorithmus, bei dem jedes Element des Arrays nacheinander überprüft wird, bis das gesuchte Element gefunden oder das Ende des Arrays erreicht ist.
      </div>
    </details>

    <details name="accordion">
      <summary>Binäre Suche</summary>
      <div>
        Ein effizienter Suchalgorithmus, der in einem sortierten Array arbeitet. Es wird wiederholt das mittlere Element überprüft, und das Suchgebiet wird auf die linke oder rechte Hälfte eingeschränkt, je nachdem, ob der gesuchte Wert kleiner oder grösser ist.
      </div>
    </details>

    <details name="accordion">
      <summary>Ternäre Suche</summary>
      <div>
        Ein Suchalgorithmus, der ein sortiertes Array in drei Teile aufteilt. Es überprüft zwei Trennpunkte gleichzeitig und entscheidet, in welchem Drittel der gesuchte Wert liegt, wodurch der Suchbereich schneller eingegrenzt wird.
      </div>
    </details>
  </div>
</body>
</html>