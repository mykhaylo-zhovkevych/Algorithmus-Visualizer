<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Archive</title>
    <style>

    @import 'normalize.css' layer(normalize);

    @layer normalize, base, demo;

    @layer demo {
    
    :root {
        --ease: linear(
        0 0%, 0.0039 6.25%, 0.0156 12.5%,
        0.0352 18.75%, 0.0625 25%,
        0.0977 31.25%, 0.1407 37.5%,
        0.1914 43.74%, 0.2499 49.99%,
        0.3164 56.25%, 0.3906 62.5%, 0.5625 75%,
        0.7656 87.5%, 1 100%
       );
    }
    
    summary {
        width: 100%;
        padding-block: 1rem;
        border-bottom: 1px solid canvasText;
    }

    summary:focus-visible {
        outline-offset: 4px;
        outline-color: red;
    }

    details span {
        display: inline-block;
        width: 100%;
        overflow: hidden;
        font-weight: 300;
        transition-duration: 1s;
        padding-block: 1rem;
    }

    details {
        width: 70ch;
    }
    
    details {
        interpolate-size: allow-keywords;
    }

    details::details-content {
        overflow: hidden;
        opacity: 0;
        height: 0;
        filter: blur(4px);
        translate: 0 1lh;
        transition: content-visibility, opacity, height, background, filter, translate;
        transition-behavior: allow-discrete;
        transition-duration: calc(var(--duration, 0.5) * 1s);
        transition-timing-function: var(--ease);
        mask: linear-gradient(#000 calc(100% - 1rem), #0000);
    }

    [open]::details-content {
      height: fit-content;
      filter: blur(0px);
      opacity: 1;
      translate: 0 0;
    }

    summary {
        display: flex;
        font-weight: 600;
        cursor: pointer;
        position: relative;
        padding-block: 1rem;

    }

    .list {
      width: auto;
      height: 100vh;
      overflow-y: auto;
      mask: linear-gradient(#0000, #fff 10rem calc(80% - 20rem), #0000);
      padding-top: 30%;
    }

    .list::-webkit-scrollbar {
      display: none; 
    }

    summary::after {
        content: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke-width='1.5' stroke='currentColor' %3E%3Cpath stroke-linecap='round' stroke-linejoin='round' d='M19.5 8.25l-7.5 7.5-7.5-7.5' /%3E%3C/svg%3E%0A");
        position: absolute;
        top: 50%;
        right: 0;
        width: 20px;
        translate: 0 -35%;
        transition: scale calc(var(--duration, 0.5) * 1s) var(--ease);
        transform-origin: 50% 40%;
    }

    [data-theme='dark'] summary::after {
        filter: invert(-1);
    }

  
    @media (prefers-color-scheme: dark) {
        summary::after {
        filter: invert(1);
        }
    }

    details[open] summary::after {
        scale: -1;
        }
    }

    @layer base {
    *,
    *:after,
    *:before {
        box-sizing: border-box;
    }

    body {
        display: flex;
        justify-content: center; 
        align-items: center;   
        min-height: 100vh;      
        margin: 0;
    }

    ::view-transition-new(root) {
      animation: fadeInScale calc(var(--duration) * 5s);
      z-index: 2;
      opacity: 0;
      transform: scale(0.8);
    }
  
    @keyframes fadeInScale {
      0% {
        opacity: 0;
        transform: scale(0.8);
      }
      100% {
        opacity: 1;
        transform: scale(1);
      }
    }
  }
</style>
</head>
<body>
  <div class="list">
    <details name="accordion">
      <summary>Sortieralgorithmus Übersicht</summary>
      <span>Hier wird eine detaillierte Erklärung der verschiedenen Algorithmen bereitgestellt.</span>
      <div>
        Jeder Algorithmus wird mit einem kurzen Codebeispiel veranschaulicht, wobei einzelne Teile des Codes direkt unter dem Beispiel weiter erklärt werden.
      </div>
      <span>

      </span>
    </details>
    <details>
      <summary>Bubble Sort</summary>
      <span><strong>Beschreibung:</strong></span>
      <div>
        Ein einfacher Vergleichsalgorithmus, bei dem benachbarte Elemente im Array wiederholt vertauscht werden, 
        wenn sie in der falschen Reihenfolge sind. Dies wird so lange wiederholt, bis das gesamte Array sortiert ist.
      </div>
      <span><strong>Code (OOP):</strong></span>
      <div>
        <pre><code>
  public class BubbleSortOOP {
      public void sort(int[] array) {
          int n = array.length;
          for (int i = 0; i < n - 1; i++) {
              for (int j = 0; j < n - i - 1; j++) {
                  if (array[j] > array[j + 1]) {
                      // Swap elements
                      int temp = array[j];
                      array[j] = array[j + 1];
                      array[j + 1] = temp;
                  }
              }
          }
      }
  }
        </code></pre>
      </div>
      <span><strong>Code (FP):</strong></span>
      <div>
        <pre><code>
  import java.util.Arrays;
  import java.util.stream.IntStream;
  
  public class BubbleSortFP {
      public static int[] sort(int[] array) {
          int[] sortedArray = Arrays.copyOf(array, array.length);
          IntStream.range(0, sortedArray.length - 1)
                   .forEach(i -> IntStream.range(0, sortedArray.length - i - 1)
                       .forEach(j -> {
                           if (sortedArray[j] > sortedArray[j + 1]) {
                               // Swap elements
                               int temp = sortedArray[j];
                               sortedArray[j] = sortedArray[j + 1];
                               sortedArray[j + 1] = temp;
                           }
                       }));
          return sortedArray;
      }
  }
        </code></pre>
      </div>
      <span><strong>Erklärung:</strong></span>
      <div>
        <p><strong>OOP-Ansatz:</strong> Der Algorithmus wird in einer Klasse gekapselt, und die Methode <code>sort</code> verarbeitet das Array. Dieser Ansatz betont die Strukturierung und Wiederverwendbarkeit.</p>
        <p><strong>FP-Ansatz:</strong> Funktionale Programmierung wird durch Streams und Lambdas erreicht. Die ursprüngliche Reihenfolge bleibt erhalten, indem eine Kopie des Arrays erstellt wird, was Unveränderlichkeit fördert.</p>
      <span>
        
      </span>
      </div>
    </details>
    <details name="accordion">
      <summary>Insertion Sort</summary>
      <span>
        
      </span>
      <div>
        Beschreibung:
        Insertion Sort ist ein einfacher Sortieralgorithmus, der eine Liste von Elementen durch iteratives Einfügen jedes einzelnen Elements in seine richtige Position innerhalb des sortierten Teils der Liste sortiert. Er funktioniert ähnlich wie das Sortieren von Karten in der Hand.
      </div>
      <ul>
        <li><strong>Komplexität:</strong> O(n²) im schlimmsten Fall (bei bereits sortierten Listen: O(n)).</li>
        <li><strong>Stabil:</strong> Behält die Reihenfolge von Elementen mit gleichen Werten bei.</li>
        <li><strong>In-place:</strong> Es wird nur wenig zusätzlicher Speicher benötigt, da die Sortierung direkt in der Eingabeliste stattfindet.</li>
        <li><strong>Eignung:</strong> Gut für kleine Listen oder fast sortierte Daten.</li>
      </ul>
      <span>
        
      </span>
    </details>
    <details name="accordion">
      <summary>Merge Sort</summary>
      <span>
        
      </span>
      <p><strong>Beschreibung:</strong> 
        Merge Sort ist ein Divide-and-Conquer-Algorithmus. Er teilt die Liste rekursiv in zwei Hälften, sortiert jede Hälfte und fügt sie dann zusammen. Der Algorithmus verwendet eine zusätzliche Liste zum Mergen der Teillisten.
      </p>
      <ul>
          <li><strong>Komplexität:</strong> O(n log n) im besten, schlechtesten und durchschnittlichen Fall.</li>
          <li><strong>Nicht stabil:</strong> Der Algorithmus könnte die Reihenfolge von gleichen Elementen ändern.</li>
          <li><strong>Externe Sortierung:</strong> Gut geeignet, um grosse Datenmengen zu sortieren, die nicht vollständig im Arbeitsspeicher gespeichert werden können.</li>
          <li><strong>Wichtige Eigenschaft:</strong> Merge Sort hat eine stabile Laufzeit, da er immer in O(n log n) arbeitet, unabhängig von der Reihenfolge der Eingabedaten.</li>
      </ul>
      <span>

      </span>

    </details>
    <details name="accordion">
      <summary>Quick Sort</summary>
      <span>
        
      </span>
      <p><strong>Beschreibung:</strong> 
        Quick Sort ist ein weiterer Divide-and-Conquer-Algorithmus, der ein "Pivot" (Schlüsselwert) auswählt und das Array so umordnet, dass alle Elemente kleiner als der Pivot links und alle grösseren rechts davon stehen. Der Algorithmus wird dann rekursiv auf die Teillisten angewendet.
      </p>
      <ul>
          <li><strong>Komplexität:</strong> O(n log n) im besten und durchschnittlichen Fall, O(n²) im schlechtesten Fall (bei schlechtem Pivot).</li>
          <li><strong>Stabil:</strong> Nicht stabil, da die Reihenfolge von gleichen Elementen geändert werden kann.</li>
          <li><strong>In-place:</strong> Keine zusätzliche Speicherung nötig, da die Sortierung direkt in der Liste erfolgt.</li>
          <li><strong>Eignung:</strong> Sehr schnell in der Praxis, wenn der Pivot gut gewählt wird (z.B. durch Zufall oder Median).</li>
      </ul>
      <span>
        
      </span>
    </details>
   
    <details name="accordion">
      <summary>Lineare Suche</summary>
      <span>
        
      </span>
      <p><strong>Beschreibung:</strong> 
        Bei der linearen Suche wird jedes Element einer Liste nacheinander auf Übereinstimmung mit dem gesuchten Wert überprüft, bis entweder das Element gefunden oder das Ende der Liste erreicht ist.
      </p>
      <ul>
          <li><strong>Komplexität:</strong> O(n), da jedes Element im schlimmsten Fall überprüft werden muss.</li>
          <li><strong>Stabilität:</strong> Nicht relevant, da es keine Reihenfolge bei den Elementen gibt.</li>
          <li><strong>Eignung:</strong> Wird oft für unsortierte Daten verwendet, wenn eine schnelle Implementierung erforderlich ist.</li>
          <li><strong>Vorteil:</strong> Sehr einfach und erfordert keine Vorverarbeitung (wie Sortierung).</li>
      </ul>
      <span>

      </span>
    </details>
    <details name="accordion">
      <summary>Binäre Suche</summary>
      <span>
        
      </span>
      <p><strong>Beschreibung:</strong> 
        Binäre Suche ist ein sehr effizienter Suchalgorithmus, der auf einer sortierten Liste arbeitet. Der Algorithmus teilt die Liste immer wieder in zwei Hälften und vergleicht den gesuchten Wert mit dem mittleren Element. Die Suche wird dann in der entsprechenden Hälfte fortgesetzt.
      </p>
      <ul>
          <li><strong>Komplexität:</strong> O(log n), da die Liste in jeder Iteration halbiert wird.</li>
          <li><strong>Voraussetzung:</strong> Die Liste muss vorab sortiert sein.</li>
          <li><strong>Nicht stabil:</strong> Da der Algorithmus nur nach einem Wert sucht, gibt es keine Problematik mit der Stabilität.</li>
          <li><strong>Eignung:</strong> Sehr schnell für grosse sortierte Listen.</li>
      </ul>
      <span>

      </span>
    </details>
    <details name="accordion">
      <summary>Ternäre Suche</summary>
      <span>

      </span>
      <p><strong>Beschreibung:</strong> 
        Die ternäre Suche ist ähnlich wie die binäre Suche, aber anstatt die Liste in zwei Hälften zu teilen, wird sie in drei Teile aufgeteilt. Der gesuchte Wert wird mit den beiden mittleren Elementen verglichen, und die Suche wird in der entsprechenden der drei Teilmengen fortgesetzt.
      </p>
      <ul>
          <li><strong>Komplexität:</strong> O(log₃ n) oder O(log n / log 3), was theoretisch besser ist als binäre Suche, aber in der Praxis nicht immer effizienter.</li>
          <li><strong>Voraussetzung:</strong> Die Liste muss sortiert sein.</li>
          <li><strong>Nicht stabil:</strong> Da auch hier nur nach einem Wert gesucht wird, ist Stabilität nicht relevant.</li>
          <li><strong>Eignung:</strong> Weniger oft verwendet als binäre Suche, da der Gewinn in der Praxis minimal ist. Wird selten bevorzugt.</li>
      </ul>
      <span>

      </span>
    </details>
  </div>
</body>
</html>